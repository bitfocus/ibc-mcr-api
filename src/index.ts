// Filename: index.ts
import 'zod-openapi/extend' // Must be at the top
import { createDocument } from 'zod-openapi'
import express, { type Application } from 'express'
import swaggerUi from 'swagger-ui-express'
import path from 'node:path'
import * as yaml from 'js-yaml'

// Import our route helpers and routes
import { createRouterAndApiPaths } from './utils/route-helpers'
import { routes } from './routes'
import { prisma } from './utils/prisma'
import { requestLogger, logger } from './utils/logger'

// Import schemas for OpenAPI components
import {
	eventIdRef,
	titleRef,
	sourceIdRef,
	sourceLabelRef,
	destinationIdRef,
	destinationLabelRef,
	eventResponseRef,
	errorResponseRef,
	notFoundResponseRef,
	eventIdSchema,
	titleSchema,
	sourceIdSchema,
	sourceLabelSchema,
	destinationIdSchema,
	destinationLabelSchema,
	eventSuccessResponseSchema,
	errorSchema,
	notFoundSchema,
} from './schemas'

const app: Application = express()

// Add request logging middleware
app.use(requestLogger)

app.use(express.json()) // Middleware to parse JSON request bodies

// Serve static files from the React app in production
if (process.env.NODE_ENV === 'production') {
	app.use(express.static(path.join(__dirname, '../public')))
}

// --- Create Router and OpenAPI Path definitions from our route configs ---
// @ts-ignore - We're mixing different route types, but the function can handle it
const { router: apiRouter, openApiPaths } = createRouterAndApiPaths(routes)

// Mount the generated API router (e.g., under a /api/v1 prefix)
app.use('/api/v1', apiRouter)

// --- Generate the OpenAPI Document ---
const document = createDocument({
	openapi: '3.1.0',
	info: {
		title: 'IBC MCR Accelerator API Draft',
		version: '0.0.1',
		description: 'Intent API for the IBC MCR Accelerator between orchestrators and cloud service vendors',
	},
	paths: openApiPaths, // Use the paths generated by createRouterAndApiPaths
	components: {
		schemas: {
			// List all schemas that have a `.openapi({ ref: "..." })`
			[eventIdRef]: eventIdSchema,
			[titleRef]: titleSchema,
			[sourceIdRef]: sourceIdSchema,
			[sourceLabelRef]: sourceLabelSchema,
			[destinationIdRef]: destinationIdSchema,
			[destinationLabelRef]: destinationLabelSchema,
			[eventResponseRef]: eventSuccessResponseSchema,
			[errorResponseRef]: errorSchema,
			[notFoundResponseRef]: notFoundSchema,
			// Add any other globally referenced schemas here
		},
		// You can also define securitySchemes, parameters, etc. here
		// securitySchemes: { BasicAuth: { type: 'http', scheme: 'basic' } }
	},
	// Define servers to specify the API base path
	servers: [{ url: '/api/v1', description: 'Main API' }],
})

// --- Serve Swagger UI Documentation ---
app.use('/docs', swaggerUi.serve, swaggerUi.setup(document))

// --- Serve OpenAPI YAML ---
app.get('/api/v1/openapi.yaml', (req, res) => {
	const yamlString = yaml.dump(document)
	res.setHeader('Content-Type', 'text/yaml')
	res.send(yamlString)
})

// Function to seed the database if it's empty
async function seedDatabaseIfEmpty() {
	try {
		// Check if there are any events in the database
		const eventCount = await prisma.event.count()

		if (eventCount === 0) {
			logger.info('Database is empty. Seeding with initial data...')

			// Create a sample event with sources, destinations, partylines, ports, and flow edges
			const event = await prisma.event.create({
				data: {
					title: 'Sample Event',
					sources: {
						create: [
							{
								label: 'Main Camera',
								ports: {
									create: [
										{
											type: 'video',
											channel: 1,
											description: 'Main video feed',
										},
										{
											type: 'audio',
											channel: 1,
											description: 'Left audio channel',
										},
										{
											type: 'audio',
											channel: 2,
											description: 'Right audio channel',
										},
									],
								},
							},
						],
					},
					destinations: {
						create: [
							{
								label: 'Output Stream 1',
								ports: {
									create: [
										{
											type: 'video',
											channel: 1,
											description: 'Main video output',
										},
										{
											type: 'audio',
											channel: 1,
											description: 'Left audio output',
										},
										{
											type: 'audio',
											channel: 2,
											description: 'Right audio output',
										},
									],
								},
							},
						],
					},
					partylines: {
						create: [
							{
								title: 'Main Communication Channel',
							},
						],
					},
				},
				include: {
					sources: {
						include: {
							ports: true,
						},
					},
					destinations: {
						include: {
							ports: true,
						},
					},
					partylines: true,
				},
			})

			// Create flow edges between source and destination ports
			if (event.sources[0]?.ports && event.destinations[0]?.ports) {
				// Connect video ports
				const videoSourcePort = event.sources[0].ports.find((p) => p.type === 'video' && p.channel === 1)
				const videoDestPort = event.destinations[0].ports.find((p) => p.type === 'video' && p.channel === 1)

				if (videoSourcePort && videoDestPort) {
					await prisma.flowEdge.create({
						data: {
							sourcePortId: videoSourcePort.id,
							destinationPortId: videoDestPort.id,
						},
					})
					logger.success(`Created flow edge: Video port ${videoSourcePort.id} -> ${videoDestPort.id}`)
				}

				// Connect audio ports (channel 1)
				const audioSourcePort1 = event.sources[0].ports.find((p) => p.type === 'audio' && p.channel === 1)
				const audioDestPort1 = event.destinations[0].ports.find((p) => p.type === 'audio' && p.channel === 1)

				if (audioSourcePort1 && audioDestPort1) {
					await prisma.flowEdge.create({
						data: {
							sourcePortId: audioSourcePort1.id,
							destinationPortId: audioDestPort1.id,
						},
					})
					logger.success(`Created flow edge: Audio port ${audioSourcePort1.id} -> ${audioDestPort1.id}`)
				}

				// Connect audio ports (channel 2)
				const audioSourcePort2 = event.sources[0].ports.find((p) => p.type === 'audio' && p.channel === 2)
				const audioDestPort2 = event.destinations[0].ports.find((p) => p.type === 'audio' && p.channel === 2)

				if (audioSourcePort2 && audioDestPort2) {
					await prisma.flowEdge.create({
						data: {
							sourcePortId: audioSourcePort2.id,
							destinationPortId: audioDestPort2.id,
						},
					})
					logger.success(`Created flow edge: Audio port ${audioSourcePort2.id} -> ${audioDestPort2.id}`)
				}
			}

			logger.success(`Seeded database with event: ${event.id} - ${event.title}`)
			logger.success(`Created source: ${event.sources[0].id} - ${event.sources[0].label}`)
			logger.success(`Created destination: ${event.destinations[0].id} - ${event.destinations[0].label}`)
			logger.success(`Created partyline: ${event.partylines[0].id} - ${event.partylines[0].title}`)
		} else {
			logger.info(`Database already contains ${eventCount} events. Skipping seeding.`)
		}
	} catch (error) {
		logger.error(`Error seeding database: ${error}`)
	}
}

// --- Start the Server ---
const PORT = process.env.PORT || 3000
app.listen(PORT, async () => {
	logger.info(`Server is running on http://localhost:${PORT}`)
	logger.info(`API Docs available at http://localhost:${PORT}/docs`)
	logger.info(`API endpoints available under http://localhost:${PORT}/api/v1`)

	// Seed the database if needed
	await seedDatabaseIfEmpty()
})

// Serve the React app for any request that doesn't match an API route
// This should be after all other routes
if (process.env.NODE_ENV === 'production') {
	app.get('*', (req, res) => {
		res.sendFile(path.join(__dirname, '../public/index.html'))
	})
}
