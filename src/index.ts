// Filename: index.ts
import "zod-openapi/extend"; // Must be at the top
import { createDocument } from "zod-openapi";
import express, { type Application } from "express";
import swaggerUi from "swagger-ui-express";

// Import our route helpers and routes
import { createRouterAndApiPaths } from "./utils/route-helpers";
import { routes } from "./routes";
import { prisma } from "./utils/prisma";

// Import schemas for OpenAPI components
import {
	eventIdRef,
	titleRef,
	sourceIdRef,
	sourceLabelRef,
	destinationIdRef,
	destinationLabelRef,
	eventResponseRef,
	errorResponseRef,
	notFoundResponseRef,
	eventIdSchema,
	titleSchema,
	sourceIdSchema,
	sourceLabelSchema,
	destinationIdSchema,
	destinationLabelSchema,
	sourceSchema,
	destinationSchema,
	eventSuccessResponseSchema,
	errorSchema,
	notFoundSchema,
} from "./schemas";

const app: Application = express();
app.use(express.json()); // Middleware to parse JSON request bodies

// --- Create Router and OpenAPI Path definitions from our route configs ---
// @ts-ignore - We're mixing different route types, but the function can handle it
const { router: apiRouter, openApiPaths } = createRouterAndApiPaths(routes);

// Mount the generated API router (e.g., under a /api/v1 prefix)
app.use("/api/v1", apiRouter);

// --- Generate the OpenAPI Document ---
const document = createDocument({
	openapi: "3.1.0",
	info: {
		title: "IBC MCR Accelerator API Draft",
		version: "0.0.1",
		description: "Intent API for the IBC MCR Accelerator between orchestrators and cloud service vendors",
	},
	paths: openApiPaths, // Use the paths generated by createRouterAndApiPaths
	components: {
		schemas: {
			// List all schemas that have a `.openapi({ ref: "..." })`
			[eventIdRef]: eventIdSchema,
			[titleRef]: titleSchema,
			[sourceIdRef]: sourceIdSchema,
			[sourceLabelRef]: sourceLabelSchema,
			[destinationIdRef]: destinationIdSchema,
			[destinationLabelRef]: destinationLabelSchema,
			[eventResponseRef]: eventSuccessResponseSchema,
			[errorResponseRef]: errorSchema,
			[notFoundResponseRef]: notFoundSchema,
			// Add any other globally referenced schemas here
		},
		// You can also define securitySchemes, parameters, etc. here
		// securitySchemes: { BasicAuth: { type: 'http', scheme: 'basic' } }
	},
	// Define servers to specify the API base path
	servers: [{ url: "/api/v1", description: "Main API" }],
});

// --- Serve Swagger UI Documentation ---
app.use("/docs", swaggerUi.serve, swaggerUi.setup(document));

// Function to seed the database if it's empty
async function seedDatabaseIfEmpty() {
	try {
		// Check if there are any events in the database
		const eventCount = await prisma.event.count();
		
		if (eventCount === 0) {
			console.log('Database is empty. Seeding with initial data...');
			
			// Create a sample event with sources, destinations, partylines, ports, and flow edges
			const event = await prisma.event.create({
				data: {
					title: 'Sample Event',
					sources: {
						create: [
							{
								label: 'Main Camera',
								ports: {
									create: [
										{
											type: 'video',
											channel: 1,
											description: 'Main video feed'
										},
										{
											type: 'audio',
											channel: 1,
											description: 'Left audio channel'
										},
										{
											type: 'audio',
											channel: 2,
											description: 'Right audio channel'
										}
									]
								}
							}
						]
					},
					destinations: {
						create: [
							{
								label: 'Output Stream 1',
								ports: {
									create: [
										{
											type: 'video',
											channel: 1,
											description: 'Main video output'
										},
										{
											type: 'audio',
											channel: 1,
											description: 'Left audio output'
										},
										{
											type: 'audio',
											channel: 2,
											description: 'Right audio output'
										}
									]
								}
							}
						]
					},
					partylines: {
						create: [
							{
								title: 'Main Communication Channel'
							}
						]
					}
				},
				include: {
					sources: {
						include: {
							ports: true
						}
					},
					destinations: {
						include: {
							ports: true
						}
					},
					partylines: true
				}
			});
			
			// Create flow edges between source and destination ports
			if (event.sources[0]?.ports && event.destinations[0]?.ports) {
				// Connect video ports
				const videoSourcePort = event.sources[0].ports.find(p => p.type === 'video' && p.channel === 1);
				const videoDestPort = event.destinations[0].ports.find(p => p.type === 'video' && p.channel === 1);
				
				if (videoSourcePort && videoDestPort) {
					await prisma.flowEdge.create({
						data: {
							sourcePortId: videoSourcePort.id,
							destinationPortId: videoDestPort.id
						}
					});
					console.log(`Created flow edge: Video port ${videoSourcePort.id} -> ${videoDestPort.id}`);
				}
				
				// Connect audio ports (channel 1)
				const audioSourcePort1 = event.sources[0].ports.find(p => p.type === 'audio' && p.channel === 1);
				const audioDestPort1 = event.destinations[0].ports.find(p => p.type === 'audio' && p.channel === 1);
				
				if (audioSourcePort1 && audioDestPort1) {
					await prisma.flowEdge.create({
						data: {
							sourcePortId: audioSourcePort1.id,
							destinationPortId: audioDestPort1.id
						}
					});
					console.log(`Created flow edge: Audio port ${audioSourcePort1.id} -> ${audioDestPort1.id}`);
				}
				
				// Connect audio ports (channel 2)
				const audioSourcePort2 = event.sources[0].ports.find(p => p.type === 'audio' && p.channel === 2);
				const audioDestPort2 = event.destinations[0].ports.find(p => p.type === 'audio' && p.channel === 2);
				
				if (audioSourcePort2 && audioDestPort2) {
					await prisma.flowEdge.create({
						data: {
							sourcePortId: audioSourcePort2.id,
							destinationPortId: audioDestPort2.id
						}
					});
					console.log(`Created flow edge: Audio port ${audioSourcePort2.id} -> ${audioDestPort2.id}`);
				}
			}
			
			console.log(`Seeded database with event: ${event.id} - ${event.title}`);
			console.log(`Created source: ${event.sources[0].id} - ${event.sources[0].label}`);
			console.log(`Created destination: ${event.destinations[0].id} - ${event.destinations[0].label}`);
			console.log(`Created partyline: ${event.partylines[0].id} - ${event.partylines[0].title}`);
		} else {
			console.log(`Database already contains ${eventCount} events. Skipping seeding.`);
		}
	} catch (error) {
		console.error('Error seeding database:', error);
	}
}

// --- Start the Server ---
const PORT = process.env.PORT || 3000;
app.listen(PORT, async () => {
	console.log(`Server is running on http://localhost:${PORT}`);
	console.log(`API Docs available at http://localhost:${PORT}/docs`);
	console.log(`API endpoints available under http://localhost:${PORT}/api/v1`);
	
	// Seed the database if needed
	await seedDatabaseIfEmpty();
});
